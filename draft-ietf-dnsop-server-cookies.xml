<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd' []>
<rfc ipr="trust200902" category="std" docName="draft-ietf-dnsop-server-cookies-04" updates="7873">
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc private=""?>
<?rfc topblock="yes"?>
<?rfc comments="no"?>
<front>
<title abbrev="server-cookies">Interoperable Domain Name System (DNS) Server Cookies</title>

<author initials="O." surname="Sury" fullname="Ondrej Sury">
<organization>Internet Systems Consortium</organization>
<address>
<postal>
<street></street>
<city></city>
<code></code>
<country>CZ</country>
<region></region>
</postal>
<phone></phone>
<email>ondrej@isc.org</email>
<uri></uri>
</address>
</author>
<author initials="W." surname="Toorop" fullname="Willem Toorop">
<organization>NLnet Labs</organization>
<address>
<postal>
<street>Science Park 400</street>
<city>Amsterdam</city>
<code>1098 XH</code>
<country>Netherlands</country>
<region></region>
</postal>
<phone></phone>
<email>willem@nlnetlabs.nl</email>
<uri></uri>
</address>
</author>
<author initials="D." surname="Eastlake 3rd" fullname="Donald E. Eastlake 3rd">
<organization>Futurewei Technologies</organization>
<address>
<postal>
<street>1424 Pro Shop Court</street>
<city>Davenport</city>
<code>FL 33896</code>
<country>USA</country>
<region></region>
</postal>
<phone>+1-508-333-2270</phone>
<email>d3e3e3@gmail.com</email>
<uri></uri>
</address>
</author>
<author initials="M." surname="Andrews" fullname="Mark Andrews">
<organization>Internet Systems Consortium</organization>
<address>
<postal>
<street>950 Charter Street</street>
<city>Redwood City</city>
<code>CA 94063</code>
<country>USA</country>
<region></region>
</postal>
<phone></phone>
<email>marka@isc.org</email>
<uri></uri>
</address>
</author>
<date year="2020" month="October" day="26"/>

<area>Internet</area>
<workgroup>DNSOP Working Group</workgroup>


<abstract>
<t>DNS Cookies, as specified in <xref target="RFC7873"/>, are a lightweight DNS transaction
security mechanism that provide limited protection to DNS servers and
clients against a variety of denial-of-service and amplification, forgery,
or cache poisoning attacks by off-path attackers.
</t>
<t>This document provides precise directions for creating Server Cookies so
that an anycast server set including diverse implementations will
interoperate with standard clients.
</t>
<t>This document updates <xref target="RFC7873"/>
</t>
</abstract>


</front>

<middle>

<section anchor="introduction" title="Introduction">
<t>DNS Cookies, as specified in <xref target="RFC7873"/>, are a lightweight DNS transaction
security mechanism that provide limited protection to DNS servers and
clients against a variety of denial-of-service and amplification, forgery,
or cache poisoning attacks by off-path attackers. This document specifies a
means of producing interoperable strong cookies so that an anycast server
set including diverse implementations can be easily configured to
interoperate with standard clients.
</t>
<t>The threats considered for DNS Cookies and the properties of the DNS
Security features other than DNS Cookies are discussed in <xref target="RFC7873"/>.
</t>
<t>In <xref target="RFC7873"/> in Section 6 it is &quot;RECOMMENDED for simplicity that
the same Server Secret be used by each DNS server in a set of anycast
servers.&quot;  However, how precisely a Server Cookie is calculated from
this Server Secret, is left to the implementation.
</t>
<t>This guidance has led to a gallimaufry of DNS Cookie implementations,
calculating the Server Cookie in different ways. As a result, DNS Cookies
are impractical to deploy on multi-vendor anycast networks, because even
when all DNS Software share the same secret, as RECOMMENDED in Section
6 of <xref target="RFC7873"/>, the Server Cookie constructed by one implementation
cannot generally be validated by another.
</t>
<t>There is no need for DNS client (resolver) Cookies to be interoperable
across different implementations. Each client need only be able to recognize
its own cookies. However, this document does contain recommendations for
constructing Client Cookies in a Client protecting fashion.
</t>

<section anchor="contents-of-this-document" title="Contents of this document">
<t><xref target="changes"/> summarises the changes to <xref target="RFC7873"/>.
</t>
<t>In <xref target="clientCookie"/> suggestions for constructing a Client
Cookie are given.
</t>
<t>In <xref target="serverCookie"/> instructions for constructing a Server
Cookie are given.
</t>
<t>In <xref target="rollingSecret"/> instructions on updating Server Secrets are given.
</t>
<t>In <xref target="cookieAlgorithms"/> the different hash functions usable for DNS
Cookie construction are listed.  <xref target="FNV"/> and HMAC-SHA-256-64 <xref target="RFC6234"/> are
deprecated and <xref target="SipHash-2.4"/> is introduced as a REQUIRED hash function for
server side DNS Cookie implementations.
</t>
<t>IANA considerations are in <xref target="ianaConsiderations"/>.
</t>
<t>Privacy and Security Considerations in <xref target="securityConsiderations"/>.
</t>
<t>Acknowledgements are in <xref target="acknowledgements"/>.
</t>
<t>Test vectors are in <xref target="testVectors"/>.
</t>
</section>

<section anchor="terminology-and-definitions" title="Terminology and Definitions">
<t>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;,
&quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;,
&quot;RECOMMENDED&quot;, &quot;<spanx style="strong">NOT RECOMMENDED</spanx>&quot;, &quot;MAY&quot;, and
&quot;OPTIONAL&quot; in this document are to be interpreted as described in
BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all
capitals, as shown here.
</t>
<t>
<list style="symbols">
<t>&quot;IP Address&quot; is used herein as a length independent term covering
both IPv4 and IPv6 addresses.</t>
</list>
</t>
</section>
</section>

<section anchor="changes" title="Changes to [RFC7873]">
<t>In its Appendices A.1 and B.1, <xref target="RFC7873"/> provides example &quot;simple&quot; algorithms
for computing Client and Server Cookies, respectively.  These algorithms MUST
NOT be used as the resulting cookies are too weak when evaluated against modern
security standards.
</t>
<t>In its Appendix B.2, <xref target="RFC7873"/> provides an example &quot;more complex&quot; server
algorithm. This algorithm is replaced by the interoperable specification in
<xref target="serverCookie"/> of this document, which MUST be used by Server Cookie
implementations.
</t>
<t>This document has suggestions on Client Cookie construction in <xref target="clientCookie"/>.
The previous example in Appendix A.2 of <xref target="RFC7873"/> is NOT RECOMMENDED.
</t>
</section>

<section anchor="clientCookie" title="Constructing a Client Cookie">
<t>The Client Cookie is a cryptographic nonce and should be treated as such.
It is RECOMMENDED to create a new Client Cookie for each new upstream server a
Client connects to. The Client Cookie SHOULD have 64-bits of entropy.
</t>
<t>When a Server does not support DNS Cookies, the Client MUST NOT send the same
Client Cookie to that same Server again. Instead, it is recommended that the
Client does not send a Client Cookie to that Server for a certain period,
for example five minutes, before it retries with a new Client Cookie.
</t>
<t>When a Server does support DNS Cookies, the Client should store the Client
Cookie alongside the Server Cookie it registered for that Server.
</t>
<t>Except for when the Client IP address changes, there is no need to change the
Client Cookie often. It is reasonable to change the Client Cookie then only if
it has been compromised or after a relatively long period of time such as no
longer than a year. Client Cookies are not expected to survive a program
restart.
</t>

<figure align="center"><artwork align="center" type="ascii-art">
Client-Cookie = 64 bits of entropy
</artwork></figure>
<t>Previously, the recommended algorithm to compute the Client Cookie included
Client IP Address as an input to a hashing function. However, when implementing
the DNS Cookies, several DNS vendors found impractical to include the Client IP
as the Client Cookie is typically computed before the Client IP address is
known. Therefore, the requirement to put Client IP address as input was
removed.
</t>
<t>However, for privacy reasons, in order to prevent tracking of devices across
links and to not circumvent IPv6 Privacy Extensions <xref target="RFC4941"/>, Clients MUST
NOT re-use a Client or Server Cookie after the Client IP address has changed.
</t>
<t>One way to track Client IP addresses, is to register the Client IP address
alongside the Server Cookie when it receives the Server Cookie.  In subsequent
queries to the Server with that Server Cookie, the socket MAY be bound to the
Client IP address that was also used (and registered) when it received the
Server Cookie.  Failure to bind MUST then result in a new Client Cookie.
</t>
</section>

<section anchor="serverCookie" title="Constructing a Server Cookie">
<t>The Server Cookie is effectively a Message Authentication Code (MAC) and should
be treated as such.  The Server Cookie is calculated from the Client Cookie,
a series of Sub-Fields specified below, the Client IP address, and a Server
Secret known only to the servers responding on the same address in an anycast set.
</t>
<t>Changing the Server Secret regularly is RECOMMENDED but, when a secure
pseudorandom function is used, it need not be changed too frequently.  For
example once a month would be adequate.  See <xref target="rollingSecret"/> on operator and
implementation guidelines for updating a Server Secret.
</t>
<t>The 128-bit Server Cookie consists of Sub-Fields: a 1 octet Version Sub-Field,
a 3 octet Reserved Sub-Field, a 4 octet Timestamp Sub-Field and an 8 octet Hash
Sub-Field.
</t>

<figure align="center"><artwork align="center" type="ascii-art">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Version    |                   Reserved                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Timestamp                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Hash                              |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork></figure>

<section anchor="the-version-subfield" title="The Version Sub-Field">
<t>The Version Sub-Field prescribes the structure and Hash calculation formula.
This document defines Version 1 to be the structure and way to calculate the
Hash Sub-Field as defined in this Section.
</t>
</section>

<section anchor="the-reserved-subfield" title="The Reserved Sub-Field">
<t>The value of the Reserved Sub-Field is reserved for future versions of Server
Side Cookie construction.  On construction it SHOULD be set to zero octets.  On
Server Cookie verification the server MUST NOT enforce those fields to be zero
and the Hash should be computed with the received value as described in
<xref target="hashField"/>.
</t>
</section>

<section anchor="timestampField" title="The Timestamp Sub-Field">
<t>The Timestamp value prevents Replay Attacks and MUST be checked by the server
to be within a defined period of time.  The DNS Server SHOULD allow Cookies
within 1 hour period in the past and 5 minutes into the future to allow
operation of low volume clients and some limited time skew between the DNS
servers in the anycast set.
</t>
<t>The Timestamp value specifies a date and time in the form of a 32-bit unsigned
number of seconds elapsed since 1 January 1970 00:00:00 UTC, ignoring leap
seconds, in network byte order.  All comparisons involving these fields MUST
use &quot;Serial number arithmetic&quot;, as defined in <xref target="RFC1982"/>
</t>
<t>The DNS Server SHOULD generate a new Server Cookie at least if the received
Server Cookie from the Client is more than half an hour old.
</t>
</section>

<section anchor="hashField" title="The Hash Sub-Field">
<t>It's important that all the DNS servers use the same algorithm for computing
the Server Cookie.  This document defines the Version 1 of the Server Side
algorithm to be:
</t>

<figure align="center"><artwork align="center" type="ascii-art">
Hash = SipHash2.4(
    Client Cookie | Version | Reserved | Timestamp | Client-IP,
    Server Secret )
</artwork></figure>
<t>where &quot;|&quot; indicates concatenation.
</t>
<t>Notice that Client-IP is used for hash generation even though it's not included
in the cookie value itself. Client-IP can be either 4 bytes for IPv4 or 16
bytes for IPv6.
</t>
<t>The Server Secret MUST be configurable to make sure that servers in an anycast
network return consistent results.
</t>
</section>
</section>

<section anchor="rollingSecret" title="Updating the Server Secret">
<t>All servers in an anycast set must be able to verify the Server Cookies
constructed by all other servers in that anycast set at all times.  Therefore
it is vital that the Server Secret is shared among all servers before it is
used to generate Server Cookies.
</t>
<t>Also, to maximize maintaining established relationships between clients and
servers, an old Server Secret should be valid for verification purposes for a
specific period.
</t>
<t>To facilitate this, deployment of a new Server Secret MUST be done in three
stages:
</t>
<t>
<list style="hanging">
<t hangText="Stage 1">
<vspace />
The new Server Secret is deployed on all the servers in an anycast set by
the operator.</t>
</list>
</t>
<t><list style="empty">
<t>Each server learns the new Server Secret, but keeps using the previous Server
  Secret to generate Server Cookies.
</t>
<t>Server Cookies constructed with the both the new Server Secret and with
  the previous Server Secret are considered valid when verifying.
</t>
<t>After stage 1 completed, all the servers in the anycast set have learned the
  new Server Secret, and can verify Server Cookies constructed with it, but keep
  generating Server Cookies with the old Server Secret.
</t>
</list></t>
<t>
<list style="hanging">
<t hangText="Stage 2">
<vspace />
This stage is initiated by the operator after the Server Cookie is present
on all members in the anycast set.</t>
</list>
</t>
<t><list style="empty">
<t>When entering Stage 2, servers start generating Server Cookies with the new
  Server Secret. The previous Server Secret is not yet removed/forgotten about.
</t>
<t>Server Cookies constructed with the both the new Server Secret and with
  the previous Server Secret are considered valid when verifying.
</t>
</list></t>
<t>
<list style="hanging">
<t hangText="Stage 3">
<vspace />
This stage is initiated by the operator when it can be assumed that most
clients have learned the new Server Secret.</t>
</list>
</t>
<t><list style="empty">
<t>With this stage, the previous Server Secret can be removed and MUST NOT be
  used anymore for verifying.
</t>
<t>We RECOMMEND the operator to wait at least a period to be the longest TTL in
  the zones served by the server plus half an hour after it initiated Stage 2,
  before initiating Stage 3.
</t>
<t>The operator SHOULD wait at least longer than the period clients are allowed
  to use the same Server Cookie, which SHOULD be half an hour,
  see <xref target="timestampField"/>.
</t>
</list></t>
</section>

<section anchor="cookieAlgorithms" title="Cookie Algorithms">
<t><xref target="SipHash-2.4"/> is a pseudorandom function suitable as Message Authentication
Code.  This document REQUIRES compliant DNS Server to use SipHash-2.4 as a
mandatory and default algorithm for DNS Cookies to ensure interoperability
between the DNS Implementations.
</t>
<t>The construction method and pseudorandom function used in calculating and
verifying the Server Cookies are determined by the initial version byte and by
the length of the Server Cookie. Additional pseudorandom or construction
algorithms for Server Cookies might be added in the future.
</t>
</section>

<section anchor="ianaConsiderations" title="IANA Considerations">
<t>IANA is requested to create a registry on the &quot;Domain Name System (DNS) Parameters&quot;
IANA web page as follows:
</t>
<t>Registry Name: DNS Server Cookie Methods
<vspace/>
Assignment Policy: Expert Review
<vspace/>
Reference: [this document], <xref target="RFC7873"/>
<vspace/>
Note: Server Cookie method (construction and pseudorandom algorithm) are
determined by the Version in the first byte of the Cookie and by the Cookie
size. Server Cookie size is limited to the inclusive range of 8 to 32 bytes.
</t>
<texttable>
<ttcol align="right">Version</ttcol>
<ttcol align="right">Size</ttcol>
<ttcol align="left">Method</ttcol>

<c>0</c><c>8-32</c><c>reserved</c>
<c>1</c><c>8-15</c><c>unassigned</c>
<c>1</c><c>16</c><c>SipHash-2.4 [this document] <xref target="serverCookie"/></c>
<c>1</c><c>17-32</c><c>unassigned</c>
<c>2-239</c><c>8-32</c><c>unassigned</c>
<c>240-254</c><c>8-32</c><c>private use</c>
<c>255</c><c>8-32</c><c>reserved</c>
</texttable>
</section>

<section anchor="securityConsiderations" title="Security and Privacy Considerations">
<t>DNS Cookies provide limited protection to DNS servers and clients against a
variety of denial-of-service and amplification/forgery or cache poisoning
attacks by off-path attackers. They provide no protection against on-path
adversaries that can observe the plaintext DNS traffic. An on-path adversary
that can observe a Server Cookie for a client and server interaction, can use
that Server Cookie for amplification and denial-of-service forgery attacks
for the lifetime of the Server Cookie.
</t>
<t>In <xref target="RFC7873"/> it was RECOMMENDED to construct a Client Cookie by using a
pseudorandom function of the Client IP Address, the Server IP Address, and a
secret quantity known only to the client. The Client IP Address was included to
ensure that a client could not be tracked if its IP Address changes due to
privacy mechanisms or otherwise.
</t>
<t>In this document, we changed Client Cookie construction to be just 64 bits of
entropy newly created for each new upstream server the client connects to.
As a consequence additional care needs to be taken to prevent tracking of
clients.  To prevent tracking, a new Client Cookie for a server MUST be created
whenever the Client IP Address changes.
</t>
<t>Unfortunately, tracking Client IP Address Changes is impractical with servers
that do not support DNS Cookies. To prevent tracking of clients with non DNS
Cookie supporting servers, a client MUST NOT send a previously sent Client
Cookie. To prevent the creation of a new Client Cookie for each query to an non
DNS Cookies supporting server, it is RECOMMENDED to not send a Client Cookie to
that server for a certain period, for example five minute.
</t>
<t>Summarizing:
</t>
<t>
<list style="symbols">
<t>In order to provide minimal authentication, a client MUST use a
different Client Cookie for each different Server IP Address.</t>
<t>To prevent tracking of clients, a new Client Cookie MUST be created
when the Client IP Address changes.</t>
<t>To prevent tracking of clients for a non DNS Cookie supporting server,
a client MUST NOT send a previously sent Client Cookie to that server,
unless it can track Client IP Address changes for those servers too.</t>
</list>
</t>
<t>Besides the Client Cookie construction, this update on <xref target="RFC7873"/> does not
introduce any new characteristics to DNS Cookies operations and the Security
Considerations section of <xref target="RFC7873"/> still applies.
</t>
</section>

</middle>
<back>
<references title="Normative References">
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1982.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7873.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"?>
<reference anchor='SipHash-2.4' target='https://131002.net/siphash/'>
    <front>
        <title>SipHash: a fast short-input PRF</title>
    <author fullname="Jean-Philippe Aumasson" initials="J." surname="Aumasson" />
    <author fullname="Daniel J. Bernstein" initials="D. J." surname="Bernstein" />
    <date year="2012"/>
    </front>
</reference>
</references>
<references title="Informative References">
<reference anchor='FNV' target='https://datatracker.ietf.org/doc/draft-eastlake-fnv'>
    <front>
        <title>The FNV Non-Cryptographic Hash Algorithm</title>
    <author fullname="Glenn Fowler" initials="G." surname="Fowler" />
    <author fullname="Landon Curt Noll" initials="L." surname="Noll" />
    <author fullname="Kiem-Phong Vo" initials="K." surname="Vo" />
    <author fullname="Donald Eastlake" initials="D." surname="Eastlake" />
    <author fullname="Tony Hansen" initials="T." surname="Hansen" />
    <date/>
    </front>
</reference>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4941.xml"?>
<?rfc include="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6234.xml"?>
</references>

<section anchor="acknowledgements" title="Acknowledgements">
<t>Thanks to Witold Krecicki and Pieter Lexis for valuable input, suggestions and
text and above all for implementing a prototype of an interoperable DNS Cookie
in Bind9, Knot and PowerDNS during the hackathon of IETF104 in Prague.  Thanks
for valuable input and suggestions go to Ralph Dolmans, Bob Harold, Daniel
Salzman, Martin Hoffmann, Mukund Sivaraman, Petr Spacek, Loganaden Velvindron,
Bob Harold, Philip Homburg, Tim Wicinski and Brian Dickson.
</t>
</section>

<section anchor="testVectors" title="Test vectors">

<section anchor="learning-a-new-server-cookie" title="Learning a new Server Cookie">
<t>A resolver (client) sending from IPv4 address 198.51.100.100, sends a query for
<spanx style="verb">example.com</spanx> to an authoritative server listening on 192.0.2.53 from
which it has not yet learned the server cookie.
</t>
<t>The DNS requests and replies shown in this Appendix, are in a &quot;dig&quot; like format.
The content of the DNS COOKIE Option is shown in hexadecimal format after
<spanx style="verb">; COOKIE:</spanx>.
</t>

<figure align="center"><artwork align="center" type="ascii-art">
;; Sending:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 57406
;; flags:; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: 2464c4abcf10c957
;; QUESTION SECTION:
;example.com.                IN      A

;; QUERY SIZE: 52
</artwork></figure>
<t>The authoritative nameserver (server) is configured with the following secret:
e5e973e5a6b2a43f48e7dc849e37bfcf (as hex data).
</t>
<t>It receives the query at Wed Jun  5 10:53:05 UTC 2019.
</t>
<t>The content of the DNS COOKIE Option that the server will return is shown
below in hexadecimal format after <spanx style="verb">; COOKIE:</spanx>
</t>

<figure align="center"><artwork align="center" type="ascii-art">
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 57406
;; flags: qr aa; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: 2464c4abcf10c957010000005cf79f111f8130c3eee29480 (good)
;; QUESTION SECTION:
;example.com.                IN      A

;; ANSWER SECTION:
example.com.         86400   IN      A       192.0.2.34

;; Query time: 6 msec
;; SERVER: 192.0.2.53#53(192.0.2.53)
;; WHEN: Wed Jun  5 10:53:05 UTC 2019
;; MSD SIZE  rcvd: 84
</artwork></figure>
</section>

<section anchor="the-same-client-learning-a-renewed-fresh-server-cookie" title="The same client learning a renewed (fresh) Server Cookie">
<t>40 minutes later, the same resolver (client) queries the same server for
for <spanx style="verb">example.org</spanx> :
</t>

<figure align="center"><artwork align="center" type="ascii-art">
;; Sending:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 50939
;; flags:; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: 2464c4abcf10c957010000005cf79f111f8130c3eee29480
;; QUESTION SECTION:
;example.org.                IN      A

;; QUERY SIZE: 52
</artwork></figure>
<t>The authoritative nameserver (server) now generates a new Server Cookie.
The server SHOULD do this because it can see the Server Cookie send by the
client is older than half an hour <xref target="timestampField"/>, but it is also fine for
a server to generate a new Server Cookie sooner, or even for every answer.
</t>

<figure align="center"><artwork align="center" type="ascii-art">
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 50939
;; flags: qr aa; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: 2464c4abcf10c957010000005cf7a871d4a564a1442aca77 (good)
;; QUESTION SECTION:
;example.org.                IN      A

;; ANSWER SECTION:
example.org.         86400   IN      A       192.0.2.34

;; Query time: 6 msec
;; SERVER: 192.0.2.53#53(192.0.2.53)
;; WHEN: Wed Jun  5 11:33:05 UTC 2019
;; MSD SIZE  rcvd: 84
</artwork></figure>
</section>

<section anchor="another-client-learning-a-renewed-server-cookie" title="Another client learning a renewed Server Cookie">
<t>Another resolver (client) with IPv4 address 203.0.113.203 sends a request to
the same server with a valid Server Cookie that it learned before
(at Wed Jun  5 09:46:25 UTC 2019). Note that the Server Cookie has Reserved bytes set,
but is still valid with the configured secret; the Hash part is calculated
taking along the Reserved bytes.
</t>

<figure align="center"><artwork align="center" type="ascii-art">
;; Sending:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 34736
;; flags:; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: fc93fc62807ddb8601abcdef5cf78f71a314227b6679ebf5
;; QUESTION SECTION:
;example.com.                IN      A

;; QUERY SIZE: 52
</artwork></figure>
<t>The authoritative nameserver (server) replies with a freshly generated Server
Cookie for this client conformant with this specification; so with the Reserved
bits set to zero.
</t>

<figure align="center"><artwork align="center" type="ascii-art">
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 34736
;; flags: qr aa; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: fc93fc62807ddb86010000005cf7a9acf73a7810aca2381e (good)
;; QUESTION SECTION:
;example.com.                IN      A

;; ANSWER SECTION:
example.com.         86400   IN      A       192.0.2.34

;; Query time: 6 msec
;; SERVER: 192.0.2.53#53(192.0.2.53)
;; WHEN: Wed Jun  5 11:38:20 UTC 2019
;; MSD SIZE  rcvd: 84
</artwork></figure>
</section>

<section anchor="ipv6-query-with-rolled-over-secret" title="IPv6 query with rolled over secret">
<t>The query below is from a client with IPv6 address 2001:db8:220:1:59de:d0f4:8769:82b8 to a server
with IPv6 address 2001:db8:8f::53.  The client has learned a valid Server Cookie
before when the Server had the secret: dd3bdf9344b678b185a6f5cb60fca715.  The server now uses a
new secret, but it can still validate the Server Cookie provided by the client
as the old secret has not expired yet.
</t>

<figure align="center"><artwork align="center" type="ascii-art">
;; Sending:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 6774
;; flags:; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: 22681ab97d52c298010000005cf7c57926556bd0934c72f8
;; QUESTION SECTION:
;example.net.                IN      A

;; QUERY SIZE: 52
</artwork></figure>
<t>The authoritative nameserver (server) replies with a freshly generated server
cookie for this client with its new secret: 445536bcd2513298075a5d379663c962
</t>

<figure align="center"><artwork align="center" type="ascii-art">
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 6774
;; flags: qr aa; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: 22681ab97d52c298010000005cf7c609a6bb79d16625507a (good)
;; QUESTION SECTION:
;example.net.                IN      A

;; ANSWER SECTION:
example.net.         86400   IN      A       192.0.2.34

;; Query time: 6 msec
;; SERVER: 2001:db8:8f::53#53(2001:db8:8f::53)
;; WHEN: Wed Jun  5 13:36:57 UTC 2019
;; MSD SIZE  rcvd: 84
</artwork></figure>
</section>
</section>

<section anchor="implementation-status" title="Implementation status">
<t>At the time of writing, BIND from version 9.16 and Knot DNS from version 2.9.0
create Server Cookies according to the recipe described in this draft. Unbound
and NSD have an Proof of Concept implementation that has been tested for
interoperability during the hackathon at the IETF104 in Prague.  Construction
of privacy maintaining Client Cookies according to the directions in this draft
have been implemented in the getdns library and will be in the upcoming
getdns-1.6.1 release and in Stubby version 0.3.1.
</t>
</section>

</back>
</rfc>
